\name{EvolutionStrategy.int}
\alias{EvolutionStrategy.int}
\alias{print.EvolutionStrategy.int}

\title{ 
  Evolution Strategy with Integer Chromosomes
}
\description{
Uses evolution strategy to find the minima of a given fitness function.
It evolves chromosomes with limited-range integers as codons.
}
\usage{
EvolutionStrategy.int(genomeLen, codonMin, codonMax, 
    genomeMin = rep.int(codonMin, genomeLen), 
    genomeMax = rep.int(codonMax, genomeLen), 
    suggestion = NULL, popSize=4, newPerGen = 4,
    iterations = 500, terminationFitness = NA, 
    mutationChance = 1/(genomeLen+1), 
    monitorFunc = NULL, evalFunc, allowrepeat = TRUE, 
    showSettings = FALSE, verbose = FALSE, plapply = lapply)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{genomeLen}{
  Number of integers (i.e, codons) in chromosome.
}
  \item{codonMin}{
  Minimum integer value range for all codons.
}
  \item{codonMax}{
  Maximum integer value range for all codons.
}
  \item{genomeMin}{
  A vector of length \code{genomeLen} containing fine-grained control
  over individual codon's minimum. Overrides \code{codonMin}.
}
  \item{genomeMax}{
  A vector of length \code{genomeLen} containing fine-grained control
  over individual codon's maximum. Overrides \code{codonMax}.
}
  \item{suggestion}{
  The suggested chromosome to be used as the initial population.
}
  \item{popSize}{
  Size of the population generated by mutating the parent.
}
  \item{newPerGen}{
  Size of the new randomly generated chromosome added to population.
}
  \item{iterations}{
  Number of generations to evolve the population.
}
  \item{terminationFitness}{
  Target fitness. If the best chromosome's fitness reaches this value
   the algorithm terminates.
}
  \item{mutationChance}{
  The chance of a codon being mutated. It must be between 0 and 1.
}
  \item{monitorFunc}{
  A function that is called at each generation. Can be used to monitor evolution of population.
}
  \item{evalFunc}{
  Fitness function.
}
  \item{allowrepeat}{
  Allows or forbids repeated values in the chromosome.
}
  \item{showSettings}{
  Enables printing GA settings.
}
  \item{verbose}{
  Enables verbose debugging info.
}
  \item{plapply}{
  \code{lapply} function used for mapping chromosomes to fitness function.
  See details for parallelization tips.
}
}
\details{
%%  ~~ If necessary, more details than the description above ~~
\code{EvolutionStrategy.int} implements evolutionary strategy search algorithm with
chromosomes created from integer values in the range of \code{codonMin} to
\code{codonMax}. \code{genomeMin} and \code{genomeMax} allow fine-grained
control of range for individual codons.
It first creates an initial population, using suggested input
\code{suggestion} or a randomly generated chromosome.
Fitness of each chromosome is evaluated using the fitness function
\code{evalFunc}. If one of the chromosomes reaches
\code{terminationFitness}, the algorithm terminates; 
Otherwise evolutionary operator mutation is applied to the population to create a new generation.
This best candidate is chosen for the next generation, and the cycle is repeat.
This iteration continues until the required fitness is reached
or the number of generations exceeds \code{iterations}.

At each generation, the supplied \code{monitorFunc} is called, taking a
list similar to \code{EvolutionStrategy.int} returning value. 

The \code{evalFunc} receives integer sequences and must return a numeric value.
The goal of optimization would be to find a chromosome which minimizes this value.

To parallelize fitness function evaluation, set \code{plapply} to a parallelized
\code{lapply}, such as \code{mclapply} from package \code{parallel}. 
In functions that do not handle data dependencies such as \code{parLapply}, 
variables and functions required for correct execution of \code{evalFunc} 
must be exported to worker nodes before invoking \code{EvolutionStrategy.int}.
}
\value{

  \item{settings$genomeMin}{
    Minimum of individual codons as used in the function call. 
    }

  \item{Settings$genomeMax}{
    Maximum of individual codons as used in the function call. 
  }

  \item{settings$popSize}{
    Size of the mutated population as used in the function call.
  }

  \item{settings$newPerGen}{
    Size of the randomly generated population as used in the function call.
  }

  \item{settings$totalPopulation}{
    Size of the total population as used in the function call.
  }

  \item{settings$iterations}{
    Number of maximum generations as used in the function call.}

  \item{settings$suggestion}{
    Suggested chromosomes as used in the function call.}

  \item{settings$mutationChance}{
    Mutation chance as used in the function call.}

  \item{population$population}{
    The genomic data of current population.}

  \item{population$evaluations}{
    Fitness of latest generation.}

  \item{population$best}{
    Historical fitness of best chromosomes.}

  \item{population$mean}{
    Historical mean fitness of population.}

  \item{population$currentIteration}{
   Number of generations evolved until now.}
     
  \item{best$genome}{
    The best chromosome in integer sequence format.}

  \item{best$fitness}{
    The fitness of the best chromosome.}
}

\references{
This function is partially based on \code{genalg} package
by Egon Willighagen. See \url{http://cran.r-project.org/web/packages/genalg/}.
}

% \author{
% %%  ~~who you are~~
% }
% \note{
% %%  ~~further notes~~
% }
%% ~Make other sections like Warning with \section{Warning }{....} ~

\seealso{
\code{\link{GrammaticalEvolution}}
}

\examples{

# define the evaluate function
evalfunc <- function(l) {
    # maximize the odd indices and minimize the even indices
    # no repeated values are allowed
    odd <- seq(1, 20, 2)
    even <- seq(2, 20, 2)
    err <- sum(l[even]) - sum(l[odd]);

    stopifnot(!any(duplicated(l))) # no duplication allowed

    return (err)
}

monitorFunc <- function(result) {
    cat("Best of gen: ", min(result$best$fitness), "\n")
}

x <- EvolutionStrategy.int(genomeLen = 20, codonMin = 0, codonMax = 20,
                allowrepeat = FALSE, terminationFitness = -109,
                monitorFunc = monitorFunc, evalFunc = evalfunc)

print(x)

best.result <- x$best$genome
print("Odds:")
print(sort(best.result[seq(1, 20, 2)]))
print("Evens:")
print(sort(best.result[seq(2, 20, 2)]))
}

% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
%\keyword{ ~kwd1 }
%\keyword{ ~kwd2 }% __ONLY ONE__ keyword per line
